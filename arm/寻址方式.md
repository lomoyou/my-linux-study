# +++*寻址方式*

## 寄存器寻址

操作数保存在寄存器中，通过寄存器名就可以直接对寄存器中的数据进行读写。

    MOV R1, R2          ;将寄存器R2中的值传送到R1
    ADD R1, R2, R3      ;运行加法运算R2+R3, 并将结果保存到R1中

## 立即数寻址

在立即数寻址中，ARM指令中的操作数是一个常数。

    ADD R1, R1, #1      ;将R1寄存器中的值加1，并将结果保存到R1中
    MOV R1, #0xFF;      ;将0xFF写到R1寄存器中
    MOV R1, #8;         ;将8写到R1寄存器中
    ADD R1, R1, #16, 20 ; R1 = R1 + 立即数16循环右移20;

## 寄存器偏移寻址

通过第二个操作数operand2的灵活配置，可以将第二个操作数做各种左移和右移操作，作为新的操作数使用。

    MOV R2, R1, LSL, #3     ;R2 = R1 << 3
    ADD R3, R2, R1, LSL #3  ;R3 = R2 + (R1 << 3)
    ADD R3, R2, R1, LSL, R0 ;R3 = R2 + (R1 << R0)

## 寄存器间接寻址

寄存器间接寻址主要用来在内存和寄存器之间传输数据，寄存器中保存的是数据在内存中的存储地址，通过这个地址就可以在寄存器和内存之间传输数据。

    LDR R1, [R2]    ;将R2中的指作为地址，取该内存地址上的数据保存到R1
    STR R1, [R2]    ;将R2中的值作为地址，将R1寄存器的值写入该内存地址

## 基址寻址

基址寻址其实也属于寄存器间接寻址。不同在于基址寻址是将寄存器中的地址与一个偏移量相加，生成新地址，然后基于这个新地址去访问内存。

    LDR R1, [FP, #2]        ;将FP中的值加2作为新地址，取改地址上的值保存到R1
    LDR R1, [FP, #2]!       ;FP=FP+2，然后将FP指定的内存单元数据保存到R1中
    LDR R1, [FP, R0]        ;将FP+R0作为新地址，取该地址的值保存到R1
    LDR R1, [FP, R0, LSL #2]    ;将FP+R0<<2作为新地址，取该地址的值保存到R1
    LDR R1, [FP] #2         ;将FP中的值作为地址，读取该地址上的值保存到R1，然后将FP中的值加2
    STR R1, [FP, #-2]       ;将FP中的值减2，作为新地址，将R1中的值写入改地址
    STR R1, [FP], #-2       ;将FP中的值作为地址，将R1中的值写入此地址，然后FP中的值减2

## 多寄存器寻址

STM/LDM指令就属于多寄存器寻址，一次可以传输多个寄存器的值。

    LDMIA SP!, {R0-R2, R14}     ;将内存栈中的数据依次弹出到R14, R2,R1, R0
    STMDB SP!, {R0-R2, R14}     ;将R0、R1、R2、R14依次压入栈
    LDMFD SP!, {R0-R2, R14}     ;将内存栈中的数据依次弹出到R14、R2、R1、R0
    STMFD SP!, {R0-R2, R14}     ;将R0、R1、R2、R14依次压入栈

## 相对寻址

相对寻址其实也属于基地址寻址，只不过它是基址寻址的一种特殊情况。特殊在于，它是以PC指针作为基地址进行寻址的，以指令中的地址差作为偏移，两者相加后得到一个新地址，然后可以对这个地址进行读写操作。ARM中的B、BL、ADR指令其实都是采用相对寻址的。
