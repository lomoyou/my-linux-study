# *ARM 汇编指令*

## arm汇编指令格式
    <opcode> {cond} {s} <Rd>, <Rn> {, Operand2} {;annotation}

    1. <>: 代表必选项，{}代表可选项。
    2. opcode: 是二进制机器指令的操作码助记符，如mov, add。
    3. cond: 执行条件。
    4. s: 是否影响CPSR寄存器中的标志位。如subs指令会影响CPSR寄存器中的N、Z、C、V标志位。而sub指令不会。
    5. Rd: 目标寄存器。
    6. Rn: 第一个操作数的寄存器。
    7. operand2: 第二个可选操作数。
    8. ;: 分号后面的代表注释。
## 代码结构

        AREA project_name, CODE, READONLY
        ENTRY
        CODE32
    START
        ADD R1, R2, #3
    END

## 条件码和状态码

    EQ(等于，Equal) ==
    NE(不等于，Not Equal) !=
    CS(高于或同于,进位设置，Carry Set) >=
    CC(低于,进位清除，Carry Clear) <

    MI(负号，MInus) < 0
    PL(正号，PLus) >=0
    VS(溢出设置，oVerflow Set)
    VC(溢出清除，oVerflow Clear)

    HI(高于，HIgher) >
    LS(低于或同于，Lower or Same) <=
    GE(大于等于，Greater or equal) >=
    LT(小于，Less Than) <
    GT(大于，Greater Than) >
    LE(小于等于，Less or equal) <=
    AL(总是，Always) 永真
    NV(从不，Never ) 永假

## 立即数
立即树以#为前缀，0x前缀表示该立即数为十六进制，不加前缀默认是十进制。
在 ARM 数据处理指令中, 当参与操作的第二操作数为立即数时, 每个立即数都是采用一个8位的常数循环右移偶数位而间接得到（关于循环移位，其实arm中只有循环右移ROR）, 其中循环右移的位数有一个4位二进制的2倍表

示. 
1.判断一个数是否符合8位位图的原则, 首先看这个数的二进制表示中1的个数是否不超过8个. 如果不超过8个, 再看这n个1(n<=8)是否能同时放到8个二进制位中, 如果可以放进去, 再看这八个二进制位是否可以循环右移偶数位得到我们欲使用的数. 如果可以, 则此数符合8位位图原理, 是合法的立即数. 否则, 不符合。

2.无法表示的32位数, 只有通过逻辑或算术运算等其它途径获得了. 比如0xffffff00, 可以通过0x000000ff按位取反得到.

## 寻址方式

### 寄存器寻址

操作数保存在寄存器中，通过寄存器名就可以直接对寄存器中的数据进行读写。

    MOV R1, R2          ;将寄存器R2中的值传送到R1
    ADD R1, R2, R3      ;运行加法运算R2+R3, 并将结果保存到R1中

### 立即数寻址

在立即数寻址中，ARM指令中的操作数是一个常数。

    ADD R1, R1, #1      ;将R1寄存器中的值加1，并将结果保存到R1中
    MOV R1, #0xFF;      ;将0xFF写到R1寄存器中
    MOV R1, #8;         ;将8写到R1寄存器中
    ADD R1, R1, #16, 20 ; R1 = R1 + 立即数16循环右移20;

### 寄存器偏移寻址

通过第二个操作数operand2的灵活配置，可以将第二个操作数做各种左移和右移操作，作为新的操作数使用。

    MOV R2, R1, LSL, #3     ;R2 = R1 << 3
    ADD R3, R2, R1, LSL #3  ;R3 = R2 + (R1 << 3)
    ADD R3, R2, R1, LSL, R0 ;R3 = R2 + (R1 << R0)

### 寄存器间接寻址

寄存器间接寻址主要用来在内存和寄存器之间传输数据，寄存器中保存的是数据在内存中的存储地址，通过这个地址就可以在寄存器和内存之间传输数据。

    LDR R1, [R2]    ;将R2中的指作为地址，取该内存地址上的数据保存到R1
    STR R1, [R2]    ;将R2中的值作为地址，将R1寄存器的值写入该内存地址

### 基址寻址

基址寻址其实也属于寄存器间接寻址。不同在于基址寻址是将寄存器中的地址与一个偏移量相加，生成新地址，然后基于这个新地址去访问内存。

    LDR R1, [FP, #2]        ;将FP中的值加2作为新地址，取改地址上的值保存到R1
    LDR R1, [FP, #2]!       ;FP=FP+2，然后将FP指定的内存单元数据保存到R1中
    LDR R1, [FP, R0]        ;将FP+R0作为新地址，取该地址的值保存到R1
    LDR R1, [FP, R0, LSL #2]    ;将FP+R0<<2作为新地址，取该地址的值保存到R1
    LDR R1, [FP] #2         ;将FP中的值作为地址，读取该地址上的值保存到R1，然后将FP中的值加2
    STR R1, [FP, #-2]       ;将FP中的值减2，作为新地址，将R1中的值写入改地址
    STR R1, [FP], #-2       ;将FP中的值作为地址，将R1中的值写入此地址，然后FP中的值减2

### 多寄存器寻址

STM/LDM指令就属于多寄存器寻址，一次可以传输多个寄存器的值。

    LDMIA SP!, {R0-R2, R14}     ;将内存栈中的数据依次弹出到R14, R2,R1, R0
    STMDB SP!, {R0-R2, R14}     ;将R0、R1、R2、R14依次压入栈
    LDMFD SP!, {R0-R2, R14}     ;将内存栈中的数据依次弹出到R14、R2、R1、R0
    STMFD SP!, {R0-R2, R14}     ;将R0、R1、R2、R14依次压入栈

### 相对寻址

相对寻址其实也属于基地址寻址，只不过它是基址寻址的一种特殊情况。特殊在于，它是以PC指针作为基地址进行寻址的，以指令中的地址差作为偏移，两者相加后得到一个新地址，然后可以对这个地址进行读写操作。ARM中的B、BL、ADR指令其实都是采用相对寻址的。

## 存储器访问指令